import traceback
import copy
import sys

__all__ = ["Config", "Field", "RangeField", "ChoiceField", "ListField", "ConfigListField", "ConfigField", "RegistryField"]

def joinNamePath(prefix, name, index=None):
    """
    Utility function for generating nested configuration names
    """
    if index is not None:
        return "%s.%s[%s]"%(prefix, name, repr(index))
    else:
        return "%s.%s"%(prefix, name)

def typeString(aType):
    """
    Utility function for generating type strings.
    Used internally for saving Config to file
    """
    if aType is None:
        return None
    else:
        return aType.__module__+"."+aType.__name__

class ConfigMeta(type):
    """A metaclass for Config

    Adds a dictionary containing all Field class attributes
    as a class attribute called '_fields', and adds the name of each field as 
    an instance variable of the field itself (so you don't have to pass the 
    name of the field to the field constructor).

    """

    def __init__(self, name, bases, dict_):
        type.__init__(self, name, bases, dict_)
        self._fields = {}
        for b in bases:
            dict_ = dict(dict_.items() + b.__dict__.items())
        for k, v in dict_.iteritems():
            if isinstance(v, Field):
                v.name = k
                self._fields[k] = v


class FieldValidationError(ValueError):
    def __init__(self, fieldtype, fullname, msg):
        error="%s '%s' failed validation: %s" % (fieldtype, fullname, msg)
        ValueError.__init__(self, error)

class Field(object):
    """A field in a a Config.

    Instances of Field should be class attributes of Config subclasses:

    class Example(Config):
        myInt = Field(int, "an integer field!", default=0)
    """
    def __init__(self, dtype, doc, default=None, check=None, optional=False):
        """Initialize a Field.
        
        dtype ------ Data type for the field.  
        doc -------- Documentation for the field.
        default ---- A default value for the field.
        check ------ A callable to be called with the field value that returns 
                     False if the valueis invalid.  More complex inter-field 
                     validation can be written as part of Config validate() 
                     method; this will be ignored if set to None.
        optional --- When False, Config validate() will fail if value is None
        """
        self.dtype = dtype
        self.doc = doc
        self.__doc__ = doc
        self.default = default
        self.check = check
        self.optional = optional

    def rename(self, instance):
        """
        Rename an instance of this field, not the field itself. 
        Only useful for fields which hold sub-configs.
        Fields which hold subconfigs should rename each sub-config with
        the full field name as generated by joinNamePath
        """
        pass

    def validate(self, instance):
        """
        Base validation for any field.
        Ensures that non-optional fields are not None.
        Ensures type correctness
        Ensures that user-provided check function is valid
        Most derived Field types should call Field.validate if they choose
        to re-implement validate
        """
        value = self.__get__(instance)
        fullname = joinNamePath(instance._name, self.name)
        fieldType = type(self).__name__
        if not self.optional and value is None:
            msg = "Required value cannot be None"
            raise FieldValidationError(fieldType, fullname, msg)
        if value is not None and not isinstance(value, self.dtype):
            msg = " Expected type '%s', got '%s'"%(self.dtype, type(value))
            raise FieldValidationError(fieldType, fullname, msg)
        if self.check is not None and not self.check(value):
            msg = "%s is not a valid value"%str(value)
            raise FieldValidationError(fieldType, fullname, msg)


    def save(self, outfile, instance):
        """
        Saves an instance of this field to file.
        This is invoked by the owning config object, and should not be called
        directly
        """
        value = self.__get__(instance)
        fullname = joinNamePath(instance._name, self.name)
        outfile.write("%s=%s\n"%(fullname, repr(value)))

    def __get__(self, instance, owner=None):
        if instance is None or not isinstance(instance, Config):
            return self
        else:
            return instance._storage[self.name]

    def __set__(self, instance, value):        
        if value is not None:
            value = self.dtype(value)
        instance._storage[self.name]=value
        instance.setHistory(self.name)
   
    def __delete__(self, instance):
        del instance._storage[self.name]
        instance.setHistory(self.name)
    
class Config(object):
    """Base class for control objects.

    A Config object will usually have several Field instances as class 
    attributes; these are used to define most of the base class behavior.  
    Simple derived class should be able to be defined simply by setting those 
    attributes.
    """

    __metaclass__ = ConfigMeta

    def __init__(self, storage=None):
        """Initialize the Config.

        Pure-Python control objects will just use the default constructor, which
        sets up a simple Python dict as the storage for field values.

        Any other object with __getitem__, __setitem__, and __contains__ may be
        used as storage.  This is used to support C++ control objects,
        which will implement a storage interface to C++ data members in SWIG.
        """
        self._name="root"

        self.history = {}
        for field in self._fields.itervalues():
            self.history[field.name] = []

        self._storage = {}
        #load up defaults
        for field in self._fields.itervalues():
            field.__set__(self, field.default)

        #apply first batch of overides from the provided storage
        if storage is not None:
            for k,v in storage.iteritems():
                target, name = self._getTargetConfig(k)
                target._fields[name].__set__(target, v)

    @staticmethod
    def load(filename):
        """
        Construct a new Config object by executing the python code in the 
        given file.

        The python script should construct a Config name root.

        For example:
            from myModule import MyConfig

            root = MyConfig()
            root.myField = 5

        When such a file is loaded, an instance of MyConfig would be returned 
        """
        local = {}
        f = open(filename, 'r')
        exec(f.read(), {}, local)
        f.close()
        return local['root']

    def save(self, filename):
        """
        Generates a python script, which, when loaded, reproduces this Config
        """
        tmp = self._name
        self._rename("root")
        try:
            outfile = open(filename, 'w')
            self._save(outfile)
            outfile.close()
        finally:
            self._rename(tmp)

    def _save(self, outfile):
        """
        Internal use only. Save this Config to file
        """
        outfile.write("import %s\n"%(type(self).__module__))
        outfile.write("%s=%s()\n"%(self._name, typeString(type(self))))
        for field in self._fields.itervalues():
            field.save(outfile, self)
        

    def _rename(self, name):
        """
        Internal use only. 
        Rename this Config object to reflect its position in a Config hierarchy
        """
        self._name = name
        for field in self._fields.itervalues():
            field.rename(self)

    def validate(self):
        """
        Validate the Config.

        The base class implementation performs type checks on all fields by 
        calling Field.validate(). 

        Complex single-field validation can be defined by deriving new Field 
        types. As syntactic sugar, some derived Field types are defined in 
        this module which handle recursing into sub-configs 
        (ConfigField, RegistryField, ConfigListField)

        Inter-field relationships should only be checked in derived Config 
        classes after calling this method, and base validation is complete
        """
        for field in self._fields.itervalues():
            field.validate(self)
    
    def setHistory(self, fieldname):
        """
        Placeholder for adding a checkpoint in a field's history
        """
        target, name = self._getTargetConfig(fieldname)
        value = target._fields[name].__get__(target)
        target.history[name].append((value, traceback.extract_stack()[:-2]))

    def getHistory(self, fieldname, limit=0):
        """
        Placeholder for retrieving a field's history.

        Field histories are ordered lists of value, traceback pairs
        with oldest information first.
        """
        target, name = self._getTargetConfig(fieldname)
        return target.history[name][-limit:]

    def _getTargetConfig(self, fieldname):
        """
        Internal use only.

        Traverse Config hierarchy using a compoud field name 
        (e.g. fieldname="foo.bar[5].zed['foo']")
        """
        dot = fieldname.rfind(".")

        target = self
        if dot > 0: 
            try:
                path = fieldname[:dot]
                target = eval("self."+fieldname[:dot])
            except SyntaxError:
                ValueError("Malformed field name '%s'"%path)
            except AttributeError:
                ValueError("Could not find target '%s' in Config %s"%\
                        (path, self._name))
        brace = fieldname.find("[", dot)
        if brace > 0:
            name = fieldname[dot+1:brace]
        else:
            name = fieldname[dot+1:]

        if not name in target._fields:
            raise ValueError("Config does not include field '%s'"%fieldname)

        return target, name

class RangeField(Field):
    """
    Defines a Config Field which allows only a range of values.
    The range is defined by providing min and/or max values.
    If min or max is None, the range will be open in that direction
    If inclusive[Min|Max] is True the range will include the [min|max] value
    """
    def __init__(self, dtype, doc, default=None, optional=False, 
            min=None, max=None, inclusiveMin=True, inclusiveMax=False):

        if min is not None and max is not None and min > max:
            swap(min, max)
        self.min = min
        self.max = max

        self.rangeString =  "%s%s,%s%s" % \
                (("[" if inclusiveMin else "("),
                ("-inf" if self.min is None else self.min),
                ("inf" if self.max is None else self.max),
                ("]" if inclusiveMax else ")"))
        doc += "\n\tValid Range = " + self.rangeString
        if inclusiveMax:
            self.maxCheck = lambda x, y: True if y is None else x <= y
        else:
            self.maxCheck = lambda x, y: True if y is None else x < y
        if inclusiveMin:
            self.minCheck = lambda x, y: True if y is None else x >= y
        else:
            self.minCheck = lambda x, y: True if y is None else x > y
        Field.__init__(self, dtype, doc, default=default, optional=optional) 

    def validate(self, instance):
        Field.validate(self, instance)
        value = instance._storage[self.name]
        if not self.minCheck(value, self.min) or \
                not self.maxCheck(value, self.max):
            fullname = joinNamePath(instance._name, self.name)
            fieldType = type(self).__name__
            msg = "%s is outside of valid range %s"%(value, self.rangeString)
            raise FieldValidationException(fieldType, fullname, msg)
            
class ChoiceField(Field):
    """
    Defines a Config Field which allows only a set of values
    All allowed must be of the same type.
    Allowed values should be provided as a dict of value, doc string pairs

    """

    def __init__(self, dtype, doc, allowed, default=None, optional=True):
        self.allowed = dict(allowed)
        if optional and None not in self.allowed: 
            self.allowed[None]="Field is optional"

        if len(self.allowed)==0:
            raise ValueError("ChoiceFields must allow at least one choice")
        
        doc += "\nAllowed values:\n"
        for choice, choiceDoc in self.allowed.iteritems():
            if choice is not None and not isinstance(choice, dtype):
                raise ValueError("ChoiceField's allowed choice %s is of type %s. Expected %s"%\
                        (choice, type(choice), dtype))
            doc += "\t%s\t%s\n"%(str(choice), choiceDoc)

        Field.__init__(self, dtype, doc, default=default, check=None, optional=optional)

    def validate(self, instance):
        Field.validate(self, instance)
        value = self.__get__(instance)
        if value not in self.allowed:
            fullname = joinNamePath(instance._name, self.name)
            fieldType = type(self).__name__
            msg = "Value ('%s') is not allowed"%str(value)
            raise FieldValidationError(fieldtype, fullname, msg) 

class ListExpr(object):
    def __init__(self, listfield, config):
        self.name = listfield.name
        self.value = config._storage[self.name]
        self.itemType = listfield.itemType 
        self.owner = config

    def __len__(self):
        return len(self.value)

    def __getitem__(self, i):
        return self.value[i]

    def __delitem__(self, i):
        del self.value[i]
        self.owner.setHistory(self.name)

    def __setitem__(self, i, x):   
        self.value[i] = self.itemType(x)
        self.owner.setHistory(self.name)

    def __iter__(self):
        return self.value.__iter__()

    def __contains__(self, x):
        return self.value.__contains__(x)

    def index(self, x, i, j):
        return self.value.index(x,i,j)

    def append(self, x):
        self[len(self):len(self)] = [x]

    def extend(self, x):
        self[len(self):len(self)] = x

    def insert(self, i, x):
        self[i:i] = [x]

    def pop(i=None):        
        x = self[i]
        del self[i]
        self.owner.setHistory(self.name)
        return x

    def remove(x):
        del self[self.index(x)]
        self.owner.setHistory(self.name)
    
    def __repr__(self):
        return repr(self.value)

    def __str__(self):
        return str(self.value)

class ListField(Field):
    """
    Defines a field which is a container of values of type itemType

    If length is not None, then instances of this field must match this length exactly
    If minLength is not None, then instances of the field must be no shorter then minLength
    If maxLength is not None, then instances of the field must be no longer than maxLength
    
    Additionally users can provide two check functions:
    listCheck - used to validate the list as a whole, and
    itemCheck - used to validate each item individually    
    """
    def __init__(self, itemType, doc, default=None, optional=False,
            listCheck=None, itemCheck=None, length=None, minLength=None, maxLength=None):
        Field.__init__(self, ListExpr, doc, default=default, optional=optional, check=None)
        self.listCheck = listCheck
        self.itemCheck = itemCheck
        self.length=length
        self.minLength=minLength
        self.maxLength=maxLength
        self.itemType=itemType
    
    def __get__(self, instance, owner=None):
        if instance is None:
            return self
        elif instance._storage[self.name] is None:
            return None
        else:
            return ListExpr(self, instance)

    def __set__(self, instance, value):
        if value is not None:
            value = [self.itemType(x) if x is not None else None for x in value]
        instance._storage[self.name] = value
        instance.setHistory(self.name)

    def validate(self, instance):
        Field.validate(self, instance)
        value = self.__get__(instance) 
        if value is not None:
            fullname = joinNamePath(instance._name, self.name)
            fieldType = type(self).__name__
            lenValue =len(value)
            if self.length is not None and not lenValue == self.length:
                msg = "Required list length=%d, got length=%d"%(self.length, lenValue)                
                raise FieldValidationError(fieldtype, fullname, msg)
            elif self.minLength is not None and lenValue < self.minLength:
                msg = "Minimum allowed list length=%d, got length=%d"%(self.minLength, lenValue)                
                raise FieldValidationError(fieldtype, fullname, msg)
            elif self.maxLength is not None and lenValue > self.maxLength:
                msg = "Maximum allowed list length=%d, got length=%d"%(self.maxLength, lenValue)                
                raise FieldValidationError(fieldtype, fullname, msg)
            elif self.listCheck is not None and not self.listCheck(value):
                msg = "%s is not a valid value"%str(value)
                raise FieldValidationError(fieldtype, fullname, msg)
            elif self.itemCheck is not None:
                for i, v in enumerate(value):
                    if not self.itemCheck(value[i]):
                        msg="Invalid value %s at position %d"%(str(v), i)
                        raise FieldValidationError(fieldtype, fullname, msg)

class ConfigListExpr(ListExpr):
    def __setitem__(self, k, x):
        if not isinstance(k, slice):
            start, stop, step = k, k+1, 1
            x = [x]
        else:
            start, stop, step = k.indices(len(self))
        
        for i, xi in zip(range(start, stop, step), x):
            itemname = joinNamePath(self.owner._name, self.name, i)
            if isinstance(xi, self.itemType):
                xi = copy.deepcopy(xi)
                xi._rename(itemname)
            elif issubclass(xi, self.itemType):
                xi = xi()
                xi._rename(itemname)
            elif xi is not None:
                raise TypeError("%s is not an instance of %s"%(x, self.itemType))
                
            self.value[i]= xi
        self.owner.setHistory(self.name)

class ConfigField(Field):
    """
    Defines a field which is itself a Config.

    The behavior of this type of field is much like that of the base Field type.

    Note that configType must be a subclass of Config.

    If optional=False, and default=None, the field will default to a default-constucted
    instance of configType

    Additionally, to allow for fewer deep-copies, assigning an instance of ConfigField 
    a value which is itself a type with is a subclass of configType,
    rather then an instance of configType, will in fact assign a default constructed
    instance of that type.

    This means that the argument default can be a type, rather than an instance
    """
    def __init__(self, configType, doc, default=None, optional=False):
        if not issubclass(configType, Config):
            raise TypeError("configType='%s' is not a subclass of Config)"%configType)
        if default is None and not optional:
            default = configType
        Field.__init__(self, dtype=configType, doc=doc, default=default, optional=optional)
        
    def __set__(self, instance, value):
        fullname=joinNamePath(instance._name, self.name)
        if isinstance(value, self.dtype):
            value = copy.deepcopy(value)
            value._rename(fullname)
        elif isinstance(value, type) and issubclass(value, self.dtype):
            value = value()
            value._rename(fullname)
        elif value is not None:
            raise ValueError("Cannot set ConfigField '%s' to '%s'"%(fullname, str(value)))

        instance._storage[self.name]=value
        instance.setHistory(self.name)

    def rename(self, instance):
        value = self.__get__(instance)
        if value is not None:
            value._rename(joinNamePath(instance._name, self.name))
        
    def save(self, outfile, instance):
        fullname = joinNamePath(instance._name, self.name)
        value = self.__get__(instance)
        if value is not None:
            value._save(outfile)
        else:
            outfile.write("%s=%s\n"%(fullname, str(None)))

class ConfigListExpr(ListExpr):
    def __setitem__(self, k, x):
        if not isinstance(k, slice):
            start, stop, step = k, k+1, 1
            x = [x]
        else:
            start, stop, step = k.indices(len(self))
        
        for i, xi in zip(range(start, stop, step), x):
            itemname = joinNamePath(self.owner._name, self.name, i)
            if isinstance(xi, self.itemType):
                xi = copy.deepcopy(xi)
                xi._rename(itemname)
            elif issubclass(xi, self.itemType):
                xi = xi()
                xi._rename(itemname)
            elif xi is not None:
                raise TypeError("%s is not an instance of %s"%(x, self.itemType))
                
            self.value[i]= xi
        self.owner.setHistory(self.name)

class ConfigListField(ListField):
    """
    Defines a field which is a container of Config objects

    This type of Field behaves much like a ListField but is aware that each item in the 
    list is a Config object. 

    By default configType=Config. To enforce that all list items be isntances of
    a particular derived Config type, specify this argument.

    Additionally, each item in the list will behave like a ConfigField. See ConfigField
    for notes about assignment
    """
    @staticmethod
    def itemCheck(config):
        if config is not None:
            config.validate()
        return True

    def __init__(self, doc, configtype=Config, default=None, optional=False,
            listCheck=None, length=None, minLength=None, maxLength=None):
        if configtype is None:
            configtype=Config

        if not issubclass(configtype, Config):
            raise TypeError("configType='%s' is not a subclass of Config)"%str(configType))
        
        ListField.__init__(self, configtype, doc, default=default, optional=optional,
                listCheck=listCheck, itemCheck=ConfigListField.itemCheck, 
                length=length, minLength=minLength, maxLength=maxLength)
        
    def __set__(self, instance, value):
        if value is not None:
            for i, xi in enumerate(value):
                itemname = joinNamePath(instance._name, self.name, i)
                if isinstance(xi, self.itemType):
                    xi = copy.deepcopy(xi)
                    xi._rename(itemname)
                elif isinstance(xi, type) and issubclass(xi, self.itemType):
                    xi = xi()
                    xi._rename(itemname)
                elif xi is not None:
                    raise TypeError("%s is not an instance of %s"%(xi, self.itemType))
                value[i] = xi
        
        instance._storage[self.name]= value
        instance.setHistory(self.name)
        
    def __get__(self, instance, owner=None):
        if instance is None:
            return self
        elif instance._storage[self.name] is None:
            return None
        else:
            return ConfigListExpr(self, instance)

    def save(self, outfile, instance):
        values = self.__get__(instance)
        types = [type(x) if x is not None else None for x in values]
        typesStr = "["
        for t in types:
            outfile.write("import %s\n"%(t.__module__))
            typesStr += "%s, "%typeString(t)
        typesStr += "]"
        fullname = joinNamePath(instance._name, self.name)
        outfile.write("%s=%s\n"%(fullname, typesStr))
        for x in values:
            if x is not None:
                x._save(outfile)
    def rename(self, instance):
        value = self.__get__(instance)
        if value is not None:
            for i, v in enumerate(value):
                if v is not None:
                    fullname = joinNamePath(instance._name, self.name, i)
                    v._rename(fullname)

class ConfigRegistry(object):
    def __init__(self, owner, field):
        self.owner = owner
        self.fieldname = field.name
        self.basetype = field.basetype
        self.restricted = field.restricted
        self.active = None 
        self.types = copy.deepcopy(field.typemap) if field.typemap is not None else {}
        self.values = {}

    def iteritems(self):
        return self.values.iteritems()
    def itervalues(self):
        return self.values.itervalues()
    def iterkeys(self):
        return self.values.iterkeys()

    def __getitem__(self, k):
        if k not in self.types:
            raise KeyError("Unknown key '%s' in ConfigRegistry '%s'"%\
                    (k, joinNamePath(self.owner._name, self.fieldname)))
        elif k not in self.values or self.values[k] is None:
            value = self.types[k]()
            value._rename(joinNamePath(self.owner._name, self.fieldname, k))
            self.values[k] = value
        
        return self.values[k]

    def __setitem__(self, k, val):
        dtype = self.types.get(k)
        if dtype is None:
            if self.restricted:            
                raise ValueError("Cannot register '%s' in restricted ConfigRegistry %s"%\
                        (str(k), joinNamePath(self.owner._name, self.fieldname)))
            if isinstance(val, type) and issubclass(val, self.basetype):
                dtype = val
            elif isinstance(val, self.basetype):
                dtype = type(val)
            elif val is None:
                dtype = self.basetype
            else:
                raise ValueError("Invalid type %s. All values in ConfigRegistry '%s' must be of type %s"%\
                        (dtype, joinNamePath(self.owner._name, self.fieldnam), self.basetype))
            self.types[k] = dtype
        fullname = joinNamePath(self.owner._name, self.fieldname, k) 
        if val == dtype:
            val = dtype()
            val._rename(fullname)
        elif isinstance(val, dtype):
            val = copy.deepcopy(val)
            val._rename(fullname)
        elif val is not None:
            raise ValueError("Invalid type %s. ConfigRegistry entry '%s' must be of type %s"%\
                    (type(val), fullname, dtype))
        
        self.values[k] = val
        self.owner.setHistory(self.fieldname)
    
    def __delitem__(self, k):
        del self.values[k]

class RegistryField(Field):
    """
    Defines a set of name, config pairs, and an "active" choice.
    To set the active choice, assign the field to the name of the choice:

    For example:

      class AaaConfig(Config):
        somefield = Field(int, "...")

      class MyConfig(Config):
        registry = RegistryField("registry", typemap={"A":AaaConfig})
      
      instance = MyConfig()
      instance.registry['AAA'].somefield = 5
      instance.registry = "AAA"
    
    Alternatively, the last line can be written:
      instance.registry.active = "AAA"

    Validation of this field is performed only the "active" choice.
    If active is None and the field is not optional, 

    Registries come in two main flavors: restricted, and unrestricted.
    Restricted registries define all allowed mapping much the same a ChoiceField 
    does. The user provides these mappings in the argument typemap in the Field
    constructor.

    Unrestricted registries allow new entries to be added to the set at runtime.
    This enables plugin style configurations, for which the full set of valid
    configs is not known until runtime.

    Following the previous example:
      class BbbConfig(Config):
        anotherField = Field(float, "...")
      instance.registry["BBB"]=BbbConfig
    This adds another entry to the unrestricted registry, which is an instance of BbbConfig
    
    Registries also allow multiple values of the same type:
      instance.registry["CCC"]=AaaConfig
      instance.registry["BBB"]=AaaConfig

    However, once a name has been associted with a particular type, it cannot be assigned
    to a different type.

    When saving a registry, the entire set is saved, as well as the active selection
    """
    def __init__(self, doc, basetype=Config, default=None, typemap={}, restricted=False, optional=False):
        if len(typemap)==0 and restricted:
            raise ValueError("Cannot instantiate a restricted RegistryField with an empty typemap")
        if not issubclass(basetype, Config):
            raise ValueError("basetype='%s' is not allowed in RegistryField. basetype must be a subclass of Config."%(basetype))

        Field.__init__(self, ConfigRegistry, doc, default=default, check=None, optional=optional)
        self.typemap = typemap
        self.restricted=restricted
        self.basetype = basetype if basetype is not None else Config
    
    def _getOrMake(self, instance):
        registry = instance._storage.get(self.name)
        if registry is None:
            registry = ConfigRegistry(instance, self)
            instance._storage[self.name] = registry
        return registry


    def __get__(self, instance, owner=None):
        if instance is None:
            return self
        else:
            return self._getOrMake(instance)

    def __set__(self, instance, value):
        registry = self._getOrMake(instance)
        if value in registry.types or value is None:
            registry.active = value
        else:
            raise KeyError("Unknown key '%s' in RegistryField '%s'"%\
                    (value, joinNamePath(instance._name, self.name)))
        instance.setHistory(self.name)

    def __delete__(self, instance):
        self.__set__(instance, None)
        instance.setHistory(self.name)

    def rename(self, instance):
        registry = RegistryField.__get__(self, instance)
        for k, v in registry.values.iteritems():
            fullname = joinNamePath(instance._name, self.name, k)
            v._rename(fullname)

    def validate(self, instance):
        Field.validate(self, instance)
        registry = self.__get__(instance)
        if registry.active is None and not self.optional:
            fullname = joinNamePath(instance._name, self.name)
            fieldType = type(self).__name__
            msg = "Required field cannot be None"
            raise FieldValidationError(fieldType, fullname, msg)
        elif registry.active is not None:
            value = registry[registry.active]
            value.validate()
        
    def save(self, outfile, instance):
        registry = RegistryField.__get__(self, instance)
        fullname = joinNamePath(instance._name, self.name)
        typesStr = "{"
        for k, t in registry.types.iteritems():
            outfile.write("import %s\n"%(t.__module__))
            typesStr += "'%s':%s, "%(k, typeString(t))
        typesStr += "}"
        outfile.write("%s.types=%s\n"%(fullname, typesStr))
        for v in registry.values.itervalues():
            v._save(outfile)
        outfile.write("%s=%s\n"%(fullname, repr(registry.active)))
